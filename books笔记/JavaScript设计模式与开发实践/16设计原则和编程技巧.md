```js
// 封装在很大程度上表达的是数据的隐藏。一个模块或者对象可以将内部的数据或者实现细节隐藏起来，只暴露必要的接口API供外界访问
```

###### 1.设计原则

- 原则只是一种指导，没有哪条原则在实际开发中是必须遵守的。在实际开发中，搜否选择某种原则需要根据具体的环境来定。

```js
// 单一职责原则
// 里氏替换原则
// 依赖倒置原则
// 接口隔离原则
// 合成复用原则
// 最少知识原则
```

###### 2.单一职责原则(SRP)

```js
/*
单一职责原则(SRP)被定义为“引起变化的原因”。如果我们有两个动机去改写一个方法，那么这个方法就具有两个职责。每个职责都是变化的一个轴线，如果一个方法承担了过多的职责，那么在需求的变迁过程中，改写这个方法的可能性就越大。

修改代码总是一件危险的事情，特别是当两个职责耦合在一起的时候，一个职责发生变化可能会影响到其他职责的实现，造成意向不到的破坏，这种耦合性得到的是低内聚和脆弱的设计

因此，SPR原则体现为:一个对象(方法)只做一件事

SRP原则是所有原则中最简单也是最难正确运用的原则之一
*/

// SRP原则的优点: SRP原则的优点是降低了单个类或者对象的复杂度，按照复杂度把对象分解成更小的粒度，这有助于胆码的复用，也有利于进行单元测试。当一个职责需要变更的时候，不会影响到其他的职责。
// SRP原则的缺点: 增加编写代码的复杂度。当我们按照职责把对象分解成更小的粒度之后，实际上也增大了这些对象之间的相互联系的难度。
```

###### 3.最小知识原则

```js
/*
最小知识原则(LKP)说的是一个软件实体应当尽可能地与其是他实体发生相互作用。这里的软件是一个广义的概念，不仅包括对象，还包括系统，类，模块，函数，变量等。

最少知识原则要求我们再设计程序时，应当尽量减少对象之间的交互。如果两个对象之间不必彼此直接通信，那么这两个对象就不要发生直接的相互联系。常见的做法是引入一个第三者对象，来承担这些对象之间的通信作用。如果一些对象需要向另一些对象发起请求，可以通过第三者对象来转发这些请求。
*/
```

###### 4.开放-封闭原则

```js
在面向对象的程序设计中，开放-封闭(OCP)是最重要的一条原则。很多时候，一个程序具有良好的设计，往往说明它是符合开放-封闭原则的。

开放-封闭原则：软件实体(类，模块，函数)等应该是可以扩展的，但是不可修改。

开放-封闭原则是一个看起来比较虚幻的原则，并没有实际的模板教导我们怎么样亦步亦趋地实现它。但我们还是能找到一些程序尽量遵守开放-封闭原则的规律，最明显的就是找出程序中将要发生变化的地方，然后把变化封装起来。

通过封装变化的形式，可以把系统中稳定不变的部分和统一变化的部分隔离开来。在系统的演变过程中，我们只需要替换那些容易变化的部分，如果这些部分已近被封装好的，那么替换起来也相对容易。而变化之外的就是稳定的部分。在系统的演变过程中，稳定的部分是不需要改变的。

回调函数是一种特殊的挂钩。我们可以吧一部分易于变化的逻辑封装在回调函数中，然后把回调函数当做参数传入一个稳定和封闭的函数中。当回调函数被执行的时候，程序就可以因为回调函数的内部逻辑不同，而产生不同的结果。

可以这样说，开放-封闭原则是编写一个好程序的目标，其他设计原则都是达到这个目标的过程。

让程序完全封闭是不容易做到的。就算技术上做的到，也需要花费太多时间和精力。而且让程序符合开放-封闭原则的代价是引入更多的抽象层次，更多的抽象有可能会增大代码的复杂度。
```

###### 5.用对象的多态性消除分支语句

```js
// makeSound是一个稳定封闭的函数
var makeSound = function(animal){
  animal.sound()
}

var Duck = function(){}

Duck.prototype.sound = function(){
  console.log('嘎嘎嘎')
}

var Chicken = function(){}
Chicken.prototype.sound = function(){
  console.log('咯咯咯')
}
makeSound(new Duck())
```

